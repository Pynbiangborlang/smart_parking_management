---------- TRIGGERS ----------
CREATE EXTENSION pgcrypto;
BEGIN

--1 TRIGGER FOR CREATING WALLET FOR USER --
CREATE OR REPLACE FUNCTION CREATE_WALLET_ON_REG_USER()
RETURNS TRIGGER
AS $$
BEGIN
    INSERT INTO USER_WALLET(USER_ID, BALANCE) VALUES (NEW.USER_ID, 0);
    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

DROP TRIGGER IF EXISTS CREATE_WALLET_ON_REG_USER_TRIGGER ON USERS;
CREATE TRIGGER CREATE_WALLET_ON_REG_USER_TRIGGER
AFTER INSERT
ON USERS
FOR EACH ROW EXECUTE FUNCTION CREATE_WALLET_ON_REG_USER();

--2 TRIGGER FOR ENTRY SENSOR READING ON ENTRY(can implement at api level) --
CREATE OR REPLACE FUNCTION ASSIGN_PARKING_SPACE_TO_USER()
RETURNS TRIGGER 
AS $$
DECLARE  
    SID INTEGER;
    UID INTEGER;
    IS_ENTRY BOOLEAN;
BEGIN
    SELECT TYPE ILIKE 'ENTRY' INTO IS_ENTRY FROM GATES WHERE SENSOR_TAG = NEW.SENSOR_TAG;
    IF IS_ENTRY THEN
        SELECT MIN(SPACE_ID) INTO SID 
        FROM PARKING_SPACE 
        WHERE STATUS ILIKE 'AVAILABLE';

        SELECT USER_ID INTO UID 
        FROM USERS 
        WHERE RFID_TAG = CRYPT(NEW.RFID_TAG, RFID_TAG);

        IF SID IS NOT NULL AND UID IS NOT NULL THEN
		  -- ASSIGNED THE PARKING SPACE TO USER
            INSERT INTO USER_PARKING_HISTORY(USER_ID, SPACE_ID, ENTRY_TIME) 
            VALUES (UID, SID, CURRENT_TIMESTAMP);
            RETURN NEW;
        END IF;
    END IF;

    RETURN NULL;
END;
$$ LANGUAGE PLPGSQL;


DROP TRIGGER IF EXISTS ASSIGN_PARKING_SPACE_TO_USER ON GATE_SENSOR_READING;
CREATE TRIGGER ASSIGN_PARKING_SPACE_TO_USER
AFTER INSERT ON GATE_SENSOR_READING
FOR EACH ROW EXECUTE FUNCTION ASSIGN_PARKING_SPACE_TO_USER()
			   
--3 TRIGGER FOR CHECK-IN OF VEHICLES ---------
CREATE OR REPLACE FUNCTION CHECK_IN()
RETURNS TRIGGER
AS $$
DECLARE
    SID INTEGER;--SPACE_ID
    PID INTEGER;--USER_PARKING_ID
BEGIN
    SELECT PS.SPACE_ID INTO SID
    FROM PARKING_SENSOR_READING PSR
    JOIN PARKING_SENSOR PS ON PS.SENSOR_ID = PSR.SENSOR_ID
    WHERE NEW.SENSOR_ID = PS.SENSOR_ID;
	
	SELECT PARKING_ID INTO PID
        FROM USER_PARKING_HISTORY UPH
        WHERE CHECK_IN IS NULL AND CHECK_OUT IS NULL AND SPACE_ID = SID;

    IF PID IS NOT NULL THEN
        -- UPDATE PARKING SPACE STATUS
		    UPDATE PARKING_SPACE SET STATUS = "OCCUPIED" WHERE SPACE_ID = SID;
		-- UPDATE CHECKIN TIME 
        UPDATE USER_PARKING_HISTORY SET CHECK_IN = CURRENT_TIMESTAMP WHERE PARKING_ID = PID;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

DROP TRIGGER IF EXISTS CHECK_IN ON PARKING_SENSOR_READING;
CREATE TRIGGER CHECK_IN
AFTER INSERT ON PARKING_SENSOR_READING
FOR EACH ROW
WHEN (NEW.READING =1) -- INCOMING DATA AND OLD DATA NEEDS TOBE DIFFERENT 1 INDICATES CHECKIN 
EXECUTE FUNCTION CHECK_IN();

--4 TRIGGER FOR CHECK-OUT OF VEHICLES(can implement at api level) ---------
CREATE OR REPLACE FUNCTION CHECK_OUT()
RETURNS TRIGGER
AS $$
DECLARE
SID INTEGER -- assigned spaceId;
PID INTEGER -- user parking id;
BEGIN
    SELECT SPACE_ID INTO SID FROM
			  PARKING_SENSOR
			  WHERE SENSOR_ID = NEW.SENSOR_ID;
			  
	SELECT PARKING_ID INTO PID 
			  FROM USER_PARKING_HISTORY UPH
			  WHERE CHECK_IN IS NOT NULL AND CHECK_OUT IS NULL AND SPACE_ID= SID;
			  
	IF SID IS NOT NULL AND PID IS NOT NULL THEN
	         -- update user check out time
			  UPDATE USER_PARKING_HISTORY SET CHECK_OUT = CURRENT_TIMESTAMP WHERE PARKING_ID=PID AND SPACE_ID=SID;
			 -- UPDATE PARKING SPACE STATUS
		    UPDATE PARKING_SPACE SET STATUS = "AVAILABLE" WHERE SPACE_ID = SID;
			  UPDATE  

	END IF;
RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

DROP TRIGGER IF EXISTS CHECK_OUT ON PARKING_SENSOR_READING;
CREATE TRIGGER CHECK_OUT
AFTER INSERT ON PARKING_SENSOR_READING
FOR EACH ROW
WHEN (NEW.READING = 0) -- INCOMING DATA AND OLD DATA NEEDS TOBE DIFFERENT 0 INDICATES CHECK OUT 
EXECUTE FUNCTION CHECK_OUT();

--5 TRIGGER FOR GENERATE BILL OF USER ---------------------------------------
CREATE OR REPLACE FUNCTION GENERATE_BILL_FOR_USER()
RETURNS TRIGGER
AS $$
DECLARE 
  AMOUNT NUMERIC -- amount to be paid;
  BAL NUMERIC -- user wallet balance;
  WID INTEGER -- user wallet id;
BEGIN 
  SELECT (EXTRACT(EPOCH FROM (NEW.CHECK_IN - NEW.CHECK_OUT)) / 60 ) * ST.RATE_PER_MIN INTO AMOUNT 
  FROM PARKING_SPACE PS
  JOIN SPACE_TYPE ST ON ST.TYPE = PS.TYPE
  WHERE PS.SPACE_ID = NEW.SPACE_ID;

  SELECT BALANCE INTO BAL FROM USER_WALLET WHERE USER_ID = NEW.USER_ID;
  SELECT WALLET_ID INTO WID FROM USER_WALLET WHERE USER_ID = NEW.USER_ID;

  IF BAL < AMOUNT THEN
    INSERT INTO BILL (PARKING_ID, WALLET_ID, AMOUNT, DATE, STATUS) VALUES (NEW.PARKING_ID, WID, AMOUNT, CURRENT_TIMESTAMP, 'PENDING');
  ELSE
    -- deduct from wallet
    UPDATE USER_WALLET SET BALANCE = BALANCE - AMOUNT
    WHERE WALLET_ID = WID;
	-- generate the bill
    INSERT INTO BILL (PARKING_ID, WALLET_ID, AMOUNT, DATE, STATUS) VALUES (NEW.PARKING_ID, WID, AMOUNT, CURRENT_TIMESTAMP, 'PAID');
	-- update user wallet history
    INSERT INTO USER_WALLET_HISTORY(TYPE,AMOUNT,DATE,WALLET_ID) VALUES
    ('D', AMOUNT,CURRENT_TIMESTAMP, WID);
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

DROP TRIGGER IF EXISTS TRIGGER_GENERATE_BILL_FOR_USER ON USER_PARKING_HISTORY;
CREATE TRIGGER TRIGGER_GENERATE_BILL_FOR_USER
AFTER UPDATE ON USER_PARKING_HISTORY
FOR EACH ROW
WHEN (NEW.CHECK_OUT IS NOT NULL)
EXECUTE FUNCTION GENERATE_BILL_FOR_USER();

--6 TRIGGER FOR EXIT SENSOR READING ON EXIT (can implement at api level) --
CREATE OR REPLACE FUNCTION CHECK_USER_PAYMENT_STATUS()
RETURNS TRIGGER 
AS $$
DECLARE  
SID INTEGER -- parking space id
UID INTEGER -- user id
IS_EXIT BOOLEAN -- is exit gate
BEGIN
    SELECT TYPE ILIKE 'EXIT'  INTO IS_EXIT FROM PARKING_GATES WHERE SENSOR_TAG = NEW.SENSOR_TAG;
    SELECT USER_ID INTO UID FROM USERS WHERE RFID_TAG = CRPTY(NEW.RFID_TAG, RFID_TAG);
	IF EXISTS (SELECT STATUS ILIKE 'PAID' FROM BILL WHERE USER_ID=UID) AND IS_EXIT
	THEN 
	UPDATE USER_PARKING_HISTORY SET EXIT_TIME = CURRENT_TIMESTAMP WHERE USER_ID = UID AND EXIT_TIME = NULL;
	RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

DROP TRIGGER IF EXISTS CHECK_USER_PAYMENT_STATUS ON GATE_SENSOR_READING;
CREATE TRIGGER CHECK_USER_PAYMENT_STATUS
AFTER INSERT ON GATE_SENSOR_READING
FOR EACH ROW EXECUTE FUNCTION CHECK_USER_PAYMENT_STATUS()