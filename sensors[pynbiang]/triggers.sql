BEGIN
--2 TRIGGER FOR ENTRY SENSOR READING ON ENTRY(can implement at api level) --
CREATE OR REPLACE FUNCTION parking_schema.ASSIGN_PARKING_SPACE_TO_USER()
RETURNS TRIGGER 
AS $$
DECLARE  
    SID INTEGER;
    UID INTEGER;
    IS_ENTRY BOOLEAN;
BEGIN
    SELECT TYPE ILIKE 'ENTRY' INTO IS_ENTRY FROM parking_schema.GATES WHERE SENSOR_TAG = NEW.SENSOR_TAG;
    IF IS_ENTRY THEN
        SELECT MIN(SPACE_ID) INTO SID 
        FROM parking_schema.PARKING_SPACE 
        WHERE STATUS ILIKE 'AVAILABLE';

        SELECT USER_ID INTO UID 
        FROM parking_schema.USERS 
        WHERE RFID_TAG = CRYPT(NEW.RFID_TAG, RFID_TAG);

        IF SID IS NOT NULL AND UID IS NOT NULL THEN
		  -- ASSIGNED THE PARKING SPACE TO USER
            INSERT INTO parking_schema.USER_PARKING_HISTORY(USER_ID, SPACE_ID, ENTRY_TIME) 
            VALUES (UID, SID, CURRENT_TIMESTAMP);
            RETURN NEW;
        END IF;
    END IF;

    RETURN NULL;
END;
$$ LANGUAGE PLPGSQL;


DROP TRIGGER IF EXISTS ASSIGN_PARKING_SPACE_TO_USER ON parking_schema.GATE_SENSOR_READING;
CREATE TRIGGER ASSIGN_PARKING_SPACE_TO_USER
AFTER INSERT ON parking_schema.GATE_SENSOR_READING
FOR EACH ROW EXECUTE FUNCTION parking_schema.ASSIGN_PARKING_SPACE_TO_USER();
  
--3 TRIGGER FOR CHECK-IN OF VEHICLES ---------
CREATE OR REPLACE FUNCTION CHECK_IN()
RETURNS TRIGGER
AS $$
DECLARE
    SID INTEGER;--SPACE_ID
    PID INTEGER;--USER_PARKING_ID
BEGIN
    SELECT PS.SPACE_ID INTO SID
    FROM parking_schema.PARKING_SENSOR_READING PSR
    JOIN parking_schema.PARKING_SENSOR PS ON PS.SENSOR_ID = PSR.SENSOR_ID
    WHERE NEW.SENSOR_ID = PS.SENSOR_ID;
	
	SELECT PARKING_ID INTO PID
        FROM parking_schema.USER_PARKING_HISTORY UPH
        WHERE CHECK_IN IS NULL AND CHECK_OUT IS NULL AND SPACE_ID = SID;

    IF PID IS NOT NULL THEN
        -- UPDATE PARKING SPACE STATUS
		    UPDATE parking_schema.PARKING_SPACE SET STATUS = 'OCCUPIED' WHERE SPACE_ID = SID;
		-- UPDATE CHECKIN TIME 
            UPDATE parking_schema.USER_PARKING_HISTORY SET CHECK_IN = CURRENT_TIMESTAMP WHERE PARKING_ID = PID;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

DROP TRIGGER IF EXISTS CHECK_IN ON parking_schema.PARKING_SENSOR_READING;
CREATE TRIGGER CHECK_IN
AFTER INSERT ON parking_schema.PARKING_SENSOR_READING
FOR EACH ROW
WHEN (NEW.READING =1) -- INCOMING DATA AND OLD DATA NEEDS TOBE DIFFERENT 1 INDICATES CHECKIN 
EXECUTE FUNCTION CHECK_IN();

--4 TRIGGER FOR CHECK-OUT OF VEHICLES(can implement at api level) ---------
CREATE OR REPLACE FUNCTION CHECK_OUT()
RETURNS TRIGGER
AS $$
DECLARE
SID INTEGER -- assigned spaceId;
PID INTEGER -- user parking id;
BEGIN
    SELECT SPACE_ID INTO SID FROM
			  parking_schema.PARKING_SENSOR
			  WHERE SENSOR_ID = NEW.SENSOR_ID;
			  
	SELECT PARKING_ID INTO PID 
			  FROM parking_schema.USER_PARKING_HISTORY UPH
			  WHERE CHECK_IN IS NOT NULL AND CHECK_OUT IS NULL AND SPACE_ID= SID;
			  
	IF SID IS NOT NULL AND PID IS NOT NULL THEN
	         -- update user check out time
			  UPDATE parking_schema.USER_PARKING_HISTORY SET CHECK_OUT = CURRENT_TIMESTAMP WHERE PARKING_ID=PID AND SPACE_ID=SID;
			 -- UPDATE PARKING SPACE STATUS
		    UPDATE parking_schema.PARKING_SPACE SET STATUS = 'AVAILABLE' WHERE SPACE_ID = SID;
			  UPDATE  

	END IF;
RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

DROP TRIGGER IF EXISTS CHECK_OUT ON parking_schema.PARKING_SENSOR_READING;
CREATE TRIGGER CHECK_OUT
AFTER INSERT ON parking_schema.PARKING_SENSOR_READING
FOR EACH ROW
WHEN (NEW.READING = 0) -- INCOMING DATA AND OLD DATA NEEDS TOBE DIFFERENT 0 INDICATES CHECK OUT 
EXECUTE FUNCTION CHECK_OUT();

--5 TRIGGER FOR EXIT SENSOR READING ON EXIT (can implement at api level) --
CREATE OR REPLACE FUNCTION CHECK_USER_PAYMENT_STATUS()
RETURNS TRIGGER 
AS $$
DECLARE  
SID INTEGER -- parking space id
UID INTEGER -- user id
IS_EXIT BOOLEAN -- is exit gate
BEGIN
    SELECT TYPE ILIKE 'EXIT'  INTO IS_EXIT FROM parking_schema.PARKING_GATES WHERE SENSOR_TAG = NEW.SENSOR_TAG;
    SELECT USER_ID INTO UID FROM parking_schema.USERS WHERE RFID_TAG = CRPTY(NEW.RFID_TAG, RFID_TAG);
	IF EXISTS (SELECT STATUS ILIKE 'PAID' FROM BILL WHERE USER_ID=UID) AND IS_EXIT
	THEN 
	UPDATE parking_schema.USER_PARKING_HISTORY SET EXIT_TIME = CURRENT_TIMESTAMP WHERE USER_ID = UID AND EXIT_TIME = NULL;
	RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

DROP TRIGGER IF EXISTS CHECK_USER_PAYMENT_STATUS ON parking_schema.GATE_SENSOR_READING;
CREATE TRIGGER CHECK_USER_PAYMENT_STATUS
AFTER INSERT ON parking_schema.GATE_SENSOR_READING
FOR EACH ROW EXECUTE FUNCTION CHECK_USER_PAYMENT_STATUS();

COMMIT