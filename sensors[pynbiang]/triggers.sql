BEGIN;
--2 TRIGGER FOR ENTRY SENSOR READING ON ENTRY(can implement at api level) --
CREATE OR REPLACE FUNCTION parking_schema.ASSIGN_PARKING_SPACE_TO_USER()
RETURNS TRIGGER 
AS $$
DECLARE  
    SID INTEGER; -- space id;
    UID INTEGER; --user id
    IS_ENTRY BOOLEAN; -- is entry gate
BEGIN
    SELECT TYPE ILIKE 'ENTRY' INTO IS_ENTRY FROM parking_schema.GATES WHERE SENSOR_TAG = NEW.SENSOR_TAG;
    IF IS_ENTRY THEN
        SELECT MIN(SPACE_ID) INTO SID 
        FROM parking_schema.PARKING_SPACE 
        WHERE STATUS ILIKE 'AVAILABLE';

        SELECT USER_ID INTO UID 
        FROM parking_schema.USERS 
        WHERE RFID_TAG = CRYPT(NEW.RFID_TAG, RFID_TAG);

        IF SID IS NOT NULL AND UID IS NOT NULL THEN
		  -- ASSIGNED THE PARKING SPACE TO USER
            INSERT INTO parking_schema.USER_PARKING_HISTORY(USER_ID, SPACE_ID, ENTRY_TIME) 
            VALUES (UID, SID, CURRENT_TIMESTAMP);
            RETURN NEW;
        END IF;
    END IF;

    RETURN NULL;
END;
$$ LANGUAGE PLPGSQL;

DROP TRIGGER IF EXISTS ASSIGN_PARKING_SPACE_TO_USER ON parking_schema.GATE_SENSOR_READING;
CREATE TRIGGER ASSIGN_PARKING_SPACE_TO_USER
AFTER INSERT ON parking_schema.GATE_SENSOR_READING
FOR EACH ROW EXECUTE FUNCTION parking_schema.ASSIGN_PARKING_SPACE_TO_USER();
  
--3 TRIGGER FOR CHECK-IN OF VEHICLES ---------
CREATE OR REPLACE FUNCTION parking_schema.CHECK_IN()
RETURNS TRIGGER
AS $$
DECLARE
    SID INTEGER;--SPACE_ID
    PID INTEGER;--USER_PARKING_ID
BEGIN
    SELECT PS.SPACE_ID INTO SID
    FROM parking_schema.PARKING_SENSOR_READING PSR
    JOIN parking_schema.PARKING_SENSOR PS ON PS.SENSOR_ID = PSR.SENSOR_ID
    WHERE NEW.SENSOR_ID = PS.SENSOR_ID;
	
	SELECT PARKING_ID INTO PID
        FROM parking_schema.USER_PARKING_HISTORY UPH
        WHERE CHECK_IN IS NULL AND CHECK_OUT IS NULL AND SPACE_ID = SID;

    IF PID IS NOT NULL THEN
        -- UPDATE PARKING SPACE STATUS
		    UPDATE parking_schema.PARKING_SPACE SET STATUS = 'OCCUPIED' WHERE SPACE_ID = SID;
		-- UPDATE CHECKIN TIME 
            UPDATE parking_schema.USER_PARKING_HISTORY SET CHECK_IN = CURRENT_TIMESTAMP WHERE PARKING_ID = PID;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

DROP TRIGGER IF EXISTS CHECK_IN ON parking_schema.PARKING_SENSOR_READING;
CREATE TRIGGER CHECK_IN
AFTER INSERT ON parking_schema.PARKING_SENSOR_READING
FOR EACH ROW
WHEN (NEW.READING =1) -- INCOMING DATA AND OLD DATA NEEDS TOBE DIFFERENT 1 INDICATES CHECKIN 
EXECUTE FUNCTION parking_schema.CHECK_IN();

--4 TRIGGER FOR CHECK-OUT OF VEHICLES(can implement at api level) ---------
CREATE OR REPLACE FUNCTION parking_schema.CHECK_OUT()
RETURNS TRIGGER
AS $$
DECLARE
SID INTEGER; -- assigned spaceId;
PID INTEGER; -- user parking id;
BEGIN
    SELECT SPACE_ID INTO SID FROM
			  parking_schema.PARKING_SENSOR
			  WHERE SENSOR_ID = NEW.SENSOR_ID;
			  
	SELECT PARKING_ID INTO PID 
			  FROM parking_schema.USER_PARKING_HISTORY UPH
			  WHERE CHECK_IN IS NOT NULL AND CHECK_OUT IS NULL AND SPACE_ID= SID;
			  
	IF SID IS NOT NULL AND PID IS NOT NULL THEN
	         -- update user check out time
			  UPDATE parking_schema.USER_PARKING_HISTORY SET CHECK_OUT = CURRENT_TIMESTAMP WHERE PARKING_ID=PID AND SPACE_ID=SID;
			 -- UPDATE PARKING SPACE STATUS
		    UPDATE parking_schema.PARKING_SPACE SET STATUS = 'AVAILABLE' WHERE SPACE_ID = SID; 
	END IF;
RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

DROP TRIGGER IF EXISTS CHECK_OUT ON parking_schema.PARKING_SENSOR_READING;
CREATE TRIGGER CHECK_OUT
AFTER INSERT ON parking_schema.PARKING_SENSOR_READING
FOR EACH ROW
WHEN (NEW.READING = 0) -- INCOMING DATA AND OLD DATA NEEDS TOBE DIFFERENT 0 INDICATES CHECK OUT 
EXECUTE FUNCTION parking_schema.CHECK_OUT();

--5 TRIGGER FOR EXIT SENSOR READING ON EXIT (can implement at api level) --
CREATE OR REPLACE FUNCTION parking_schema.CHECK_USER_PAYMENT_STATUS()
RETURNS TRIGGER 
AS $$
DECLARE  
SID INTEGER; -- parking space id
WID INTEGER; -- user id,
UID INTEGER; -- USER ID
IS_EXIT BOOLEAN; -- is exit gate
IS_PENDING BOOLEAN; -- IF ANY PENDING BILLS
BEGIN
    SELECT TYPE ILIKE 'EXIT' INTO IS_EXIT FROM parking_schema.GATES WHERE SENSOR_TAG = NEW.SENSOR_TAG;
    
	SELECT UW.WALLET_ID, USR.USER_ID 
	INTO WID, UID 
	FROM parking_schema.USERS USR
    JOIN parking_schema.USER_WALLET UW ON UW.USER_ID = 1
    WHERE RFID_TAG = CRYPT(NEW.RFID_TAG, USR.RFID_TAG);
	
	SELECT EXISTS(SELECT 1 FROM parking_schema.BILL WHERE WALLET_ID = 1 AND STATUS ILIKE 'PENDING') INTO IS_PENDING;
	
	IF NOT IS_PENDING AND IS_EXIT THEN
	-- NO PENDING BILLS UPDATE EXIT TIME
	   UPDATE parking_schema.USER_PARKING_HISTORY SET EXIT_TIME = CURRENT_TIMESTAMP WHERE USER_ID = UID AND EXIT_TIME IS NULL;
	END IF;
RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

DROP TRIGGER IF EXISTS CHECK_USER_PAYMENT_STATUS ON parking_schema.GATE_SENSOR_READING;
CREATE TRIGGER CHECK_USER_PAYMENT_STATUS
AFTER INSERT ON parking_schema.GATE_SENSOR_READING
FOR EACH ROW EXECUTE FUNCTION parking_schema.CHECK_USER_PAYMENT_STATUS();

COMMIT;